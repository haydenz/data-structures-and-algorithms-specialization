# Data Structures and Algorithms
**About this [Specialization](https://www.coursera.org/specializations/data-structures-algorithms)**: this specialization is a mix of theory and practice
  - Learn algorithmic techniques for solving various computational problems
  - Implement about 100 algorithmic coding problems 
  - Multiple tests to check each coding problem's correctness and running time 
  - Two real-world projects: 
    1. Big Networks

        Analyze both road networks and social networks and will learn how to compute the shortest route between New York and San Francisco (1000 times faster than the standard shortest path algorithms!)
    2. Genome Assembly

        Assemble genomes from millions of short fragments of DNA and how assembly algorithms fuel recent developments in personalized medicine.

# Courses in this Specialization

## Course 1: Algorithmic Toolbox
  - **[Certificate](https://www.coursera.org/account/accomplishments/certificate/TKUCKAAZK2PV)** Grade Achieved: 94% 
  

## Course 2: Data Structures
  - **[Certificate](https://www.coursera.org/account/accomplishments/certificate/RMHRNLZ7XKKM)** Grade Achieved: 100% 
  

## Course 3: Algorithms on Graphs
  - **[Certificate](https://www.coursera.org/account/accomplishments/certificate/X3S42W3BKSUN)** Grade Achieved: 100%
  - **Level**: Intermediate
  - **Commitment**: 5 weeks of study, 3-4 hours/week
  - **Syllabus**:
    - Week 1: Decomposition of Undirected Graphs
      1. Reachability, explore, DFS
      2. Connected components
      3. Previsit and postvisit to record orderings of explore
    - Week 2: Decomposition of Directed Graphs
      1. Directed acyclic graphs
      2. Topological sort through reversing postvisit order
      3. Strongly connected components through sinks (DFS on reversed graphs)
    - Week 3: Most Direct Route
      1. Distance layers
      2. Breadth first search
      3. Proof of correctness of BFS
      4. Shortest path tree
    - Week 4: Fastest Route
      1. Dijkstra's Algorithm and its runtime
      2. Edges with negative weights
      3. Bellman-Ford Algorithm to solve negative cycles
    - Week 5: Minimum Spanning Trees
      1. MST definition
      2. Kruskal's Algorithm
      3. Prim's Algorithm
    - Week 6: Advanced Shortest Paths Project (Optional)

## Course 4: Algorithms on Strings
  - **Level**: Intermediate
  - **Commitment**: 5 weeks of study, 17 hours in total
  - **Syllabus**:
    - Week 1: Pattern Matching
      1. Herd patterns into trie
      2. Herd text into suffix trie
      3. Suffix trie to suffix tree
    - Week 2: Burrows-Weeler Transformation and Suffix Array
      1. BWT and BWT pattern matching
      2. Suffix array and pattern matching
      3. Approx. pattern matching
    - Week 3:
 
 ## Course 5: Advanced Algorithms and Complexity
   You've learned the basic algorithms now and are ready to step into the area of more complex problems and algorithms to solve them. Advanced algorithms build upon basic ones and use new ideas. We will start with networks flows which are used in more typical applications such as optimal matchings, finding disjoint paths and flight scheduling as well as more surprising ones like image segmentation in computer vision. We then proceed to linear programming with applications in optimizing budget allocation, portfolio optimization, finding the cheapest diet satisfying all requirements and many others. Next we discuss inherently hard problems for which no exact good solutions are known (and not likely to be found) and how to solve them in practice. We finish with a soft introduction to streaming algorithms that are heavily used in Big Data processing. Such algorithms are usually designed to be able to process huge datasets without being able even to store a dataset.

## Course 6: Genome Assembly Programming Challenge
  In Spring 2011, thousands of people in Germany were hospitalized with a deadly disease that started as food poisoning with bloody diarrhea and often led to kidney failure. It was the beginning of the deadliest outbreak in recent history, caused by a mysterious bacterial strain that we will refer to as E. coli X. Soon, German officials linked the outbreak to a restaurant in Lübeck, where nearly 20% of the patrons had developed bloody diarrhea in a single week. At this point, biologists knew that they were facing a previously unknown pathogen and that traditional methods would not suffice – computational biologists would be needed to assemble and analyze the genome of the newly emerged pathogen. To investigate the evolutionary origin and pathogenic potential of the outbreak strain, researchers started a crowdsourced research program. They released bacterial DNA sequencing data from one of a patient, which elicited a burst of analyses carried out by computational biologists on four continents. They even used GitHub for the project: https://github.com/ehec-outbreak-crowdsourced/BGI-data-analysis/wiki The 2011 German outbreak represented an early example of epidemiologists collaborating with computational biologists to stop an outbreak. In this Genome Assembly Programming Challenge, you will follow in the footsteps of the bioinformaticians investigating the outbreak by developing a program to assemble the genome of the E. coli X from millions of overlapping substrings of the E.coli X genome.
 
